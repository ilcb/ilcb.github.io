<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Tools/消息队列/RabbitMQ原理/RabbitMQ原理" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">RabbitMQ 原理 | DocHub</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ilcb.github.io/en/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://ilcb.github.io/en/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://ilcb.github.io/en/docs/Tools/消息队列/RabbitMQ原理"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" property="og:locale:alternate" content="zh"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="algolia-site-verification" content="7AC2C149ACF91D98"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="RabbitMQ 原理 | DocHub"><meta data-rh="true" name="description" content="RabbitMQ 是一个由 erlang 开发的 AMQP（Advanced Message Queue ）的开源实现"><meta data-rh="true" property="og:description" content="RabbitMQ 是一个由 erlang 开发的 AMQP（Advanced Message Queue ）的开源实现"><link data-rh="true" rel="icon" href="/en/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ilcb.github.io/en/docs/Tools/消息队列/RabbitMQ原理"><link data-rh="true" rel="alternate" href="https://ilcb.github.io/docs/Tools/消息队列/RabbitMQ原理" hreflang="zh"><link data-rh="true" rel="alternate" href="https://ilcb.github.io/en/docs/Tools/消息队列/RabbitMQ原理" hreflang="en"><link data-rh="true" rel="alternate" href="https://ilcb.github.io/docs/Tools/消息队列/RabbitMQ原理" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://KH2JHIT03F-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/en/blog/rss.xml" title="DocHub RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/en/blog/atom.xml" title="DocHub Atom Feed">




<link rel="search" type="application/opensearchdescription+xml" title="DocHub" href="/en/opensearch.xml"><link rel="stylesheet" href="/en/assets/css/styles.ea66e0ae.css">
<script src="/en/assets/js/runtime~main.4a130e80.js" defer="defer"></script>
<script src="/en/assets/js/main.0df2ecba.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/en/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/en/"><div class="navbar__logo"><img src="/en/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/en/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">DocHub</b></a><a class="navbar__item navbar__link" href="/en/docs/backend/java/io">后端</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Wiki</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/en/docs/backend/algorithm/sort">算法</a></li><li><a class="dropdown__link" href="/en/docs/backend/design-pattern/rules">设计模式</a></li><li><a class="dropdown__link" href="/en/docs/wiki/uml/class">UML</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">云原生</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/en/docs/cloud-native/docker/install">容器</a></li><li><a class="dropdown__link" href="/en/docs/cloud-native/harbor/install-harbor">镜像仓库</a></li><li><a class="dropdown__link" href="/en/docs/cloud-native/orchestration/install-k8s">容器编排</a></li></ul></div><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/en/docs/Tools/消息队列/RabbitMQ原理">工具</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/en/docs/Tools/消息队列/RabbitMQ原理">RabbitMQ 原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/Tools/Redis使用">Redis 使用</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/en/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">RabbitMQ 原理</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>RabbitMQ 原理</h1></header><p>RabbitMQ 是一个由 erlang 开发的 AMQP（Advanced Message Queue ）的开源实现</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是-amqp">什么是 AMQP<a href="#什么是-amqp" class="hash-link" aria-label="Direct link to 什么是 AMQP" title="Direct link to 什么是 AMQP">​</a></h2>
<p>AMQP（高级消息队列协议）是一个网络协议。支持符合要求的客户端应用（application）和消息中间件代理（messaging middleware broker）之间进行通信。
消息代理（message brokers）从发布者（publishers）亦称生产者（producers）那儿接收消息，并根据既定的路由规则把接收到的消息发送给处理消息的消费者（consumers）。
由于 AMQP 是一个网络协议，所以这个过程中的发布者，消费者，消息代理 可以存在于不同的设备上。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="amqp-原理">AMQP 原理<a href="#amqp-原理" class="hash-link" aria-label="Direct link to AMQP 原理" title="Direct link to AMQP 原理">​</a></h2>
<p><img decoding="async" loading="lazy" alt="amqp" src="/en/assets/images/amqp-6630a75fb942bff84661eff6eac40d46.png" width="1114" height="316" class="img_ev3q"></p>
<p>AMQP 工作过程如下图：消息（message）被发布者（publisher）发送给交换机（exchange），然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>
<p>发布者（publisher）发布消息时可以给消息指定各种消息属性（message meta-data）。有些属性有可能会被消息代理（brokers）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。</p>
<p>从安全角度考虑，网络是不可靠的，接收消息的应用也有可能在处理消息的时候失败。基于此原因，AMQP 模块包含了一个消息确认（message acknowledgements）的概念：当一个消息从队列中投递给消费者后，消费者会通知消息代理（broker），这个可以是自动的也可以由处理消息的应用的开发者执行。当“消息确认”被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的确认回执（acknowledgement）。</p>
<p>在某些情况下，例如当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。</p>
<p>队列，交换机和绑定统称为 AMQP 实体（AMQP entities）。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="amqp-组件及概念">AMQP 组件及概念<a href="#amqp-组件及概念" class="hash-link" aria-label="Direct link to AMQP 组件及概念" title="Direct link to AMQP 组件及概念">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="broker">Broker<a href="#broker" class="hash-link" aria-label="Direct link to Broker" title="Direct link to Broker">​</a></h3>
<p>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="virtual-host">Virtual host<a href="#virtual-host" class="hash-link" aria-label="Direct link to Virtual host" title="Direct link to Virtual host">​</a></h3>
<p>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="connection">Connection<a href="#connection" class="hash-link" aria-label="Direct link to Connection" title="Direct link to Connection">​</a></h3>
<p>publisher／consumer 和 broker 之间的 TCP 长连接。断开连接的操作只会在 client 端进行，Broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。</p>
<p>AMQP 是一个使用 TCP 提供可靠投递的应用层协议，AMQP 使用认证机制并且提供 TLS（SSL）保护，当一个应用不再需要连接到 AMQP 代理的时候，需要优雅的释放掉 AMQP 连接，而不是直接将 TCP 连接关闭</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="channel">Channel<a href="#channel" class="hash-link" aria-label="Direct link to Channel" title="Direct link to Channel">​</a></h3>
<p>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，并且这些通道不能被线程/进程共享。一个特定 Channel 上的通讯与其他 Channel 上的通讯是完全隔离的，因此每个 AMQP 方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="exchange">Exchange<a href="#exchange" class="hash-link" aria-label="Direct link to Exchange" title="Direct link to Exchange">​</a></h3>
<p>交换机(Exchange)是用来发送消息的 AMQP 实体。交换机拿到一个消息之后将它路由给一个或零个队列。使用哪种路由算法是由交换机类型和 binding key 所决定的。:</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="routing-key">Routing key<a href="#routing-key" class="hash-link" aria-label="Direct link to Routing key" title="Direct link to Routing key">​</a></h4>
<p>生产者在将消息发送给 Exchange 的时候，一般会指定一个 routing key，来指定这个消息的路由规则，而这个 routing key 需要与 Exchange Type 及 binding key 联合使用才能最终生效。</p>
<p>在设置了 Exchange Type 与 binding key 的情况下，生产者就可以在发送消息给 Exchange 时，通过指定 routing key 来决定消息流向哪里。</p>
<p>RabbitMQ 为 routing key 设定的长度限制为 255 bytes。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="route-type">Route Type<a href="#route-type" class="hash-link" aria-label="Direct link to Route Type" title="Direct link to Route Type">​</a></h4>
<p>常用的 Exchange Type 有 fanout、direct、topic、headers;</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="direct-exchange直连交换机">Direct exchange（直连交换机）<a href="#direct-exchange直连交换机" class="hash-link" aria-label="Direct link to Direct exchange（直连交换机）" title="Direct link to Direct exchange（直连交换机）">​</a></h5>
<p>直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的，直连交换机用来处理消息的单播路由。下边介绍它是如何工作的：</p>
<ul>
<li>将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（binding key）</li>
<li>当一个携带着 routing key 为<code>key</code>的消息被发送给直连交换机时，交换机会把它路由给 binding key 为<code>key</code>的队列。</li>
</ul>
<p>直连交换机经常用来循环分发任务给多个工作者（workers）。当这样做的时候，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</p>
<p>direct 交换机图例：</p>
<p><img decoding="async" loading="lazy" alt="direct" src="/en/assets/images/direct-5524e262ef77bcd35126cb3c13805535.png" width="1810" height="670" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="fanout-exchange扇型交换机">Fanout exchange（扇型交换机）<a href="#fanout-exchange扇型交换机" class="hash-link" aria-label="Direct link to Fanout exchange（扇型交换机）" title="Direct link to Fanout exchange（扇型交换机）">​</a></h5>
<p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，忽略 routing key 是否和 binding key 匹配。如果 N 个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的 N 个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。</p>
<p>fanout 交换机图例：</p>
<p><img decoding="async" loading="lazy" alt="fanout" src="/en/assets/images/fanout-944888976e27b9f92a089c1995b8d27b.png" width="1810" height="660" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="topic-exchange主题交换机">Topic exchange（主题交换机）<a href="#topic-exchange主题交换机" class="hash-link" aria-label="Direct link to Topic exchange（主题交换机）" title="Direct link to Topic exchange（主题交换机）">​</a></h5>
<p>主题交换机（topic exchanges）通过对消息的 routing key 和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。</p>
<p>主题交换机模式下 binding key 配置支持 2 种格式：</p>
<ul>
<li><code>*</code>代表任意的一个词，如 key.*能够匹配到 key.one、key.two、key.three…….</li>
<li><code>#</code>代表任意多个词，如 key.#，他能够匹配到，key.group.one 、key.group.two、key.color、key.color.name.red</li>
</ul>
<p>topic 型交换机图例：</p>
<p><img decoding="async" loading="lazy" alt="topic" src="/en/assets/images/topic-9115fbb178c823ed373e47069866e87b.png" width="1848" height="664" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="headers-exchange头交换机">Headers exchange（头交换机）<a href="#headers-exchange头交换机" class="hash-link" aria-label="Direct link to Headers exchange（头交换机）" title="Direct link to Headers exchange（头交换机）">​</a></h5>
<p>headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。</p>
<p>在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到 Exchange 时，RabbitMQ 会取到该消息的 headers（也是一个键值对的形式），对比其中的键值对是否完全匹配 Queue 与 Exchange 绑定时指定的键值对；如果完全匹配则消息会路由到该 Queue，否则不会路由到该 Queue。</p>
<p>头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="exchange-其他属性">Exchange 其他属性<a href="#exchange-其他属性" class="hash-link" aria-label="Direct link to Exchange 其他属性" title="Direct link to Exchange 其他属性">​</a></h4>
<p>除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：</p>
<ul>
<li>Name</li>
<li>Durability （消息代理重启后，交换机是否还存在）</li>
<li>Auto-delete （当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它）</li>
<li>Arguments（依赖代理本身）</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="queue">Queue<a href="#queue" class="hash-link" aria-label="Direct link to Queue" title="Direct link to Queue">​</a></h3>
<p>消息存储在 Queue 里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。
Queue 在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为 406 的通道级异常就会被抛出。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="queue-关键属性">Queue 关键属性<a href="#queue-关键属性" class="hash-link" aria-label="Direct link to Queue 关键属性" title="Direct link to Queue 关键属性">​</a></h4>
<ul>
<li>Name
队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多 255 字节的一个 utf-8 字符串。若希望 AMQP 消息代理生成队列名，需要给队列的 name 参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。
以&quot;amq.&quot;开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的 403 (ACCESS_REFUSED)错误会被抛出。</li>
<li>Durable（消息代理重启后，队列依旧存在）</li>
<li>Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）</li>
<li>Auto-delete（当最后一个消费者退订后即被删除）</li>
<li>Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="binding">Binding<a href="#binding" class="hash-link" aria-label="Direct link to Binding" title="Direct link to Binding">​</a></h3>
<p>Binding 是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="binding-key">Binding key<a href="#binding-key" class="hash-link" aria-label="Direct link to Binding key" title="Direct link to Binding key">​</a></h4>
<p>在绑定（Binding）Exchange 与 Queue 的同时，一般会指定一个 binding key；消费者将消息发送给 Exchange 时，一般会指定一个 routing key；当 binding key 与 routing key 相匹配时，消息将会被路由到对应的 Queue 中。
在绑定多个 Queue 到同一个 Exchange 的时候，这些 Binding 允许使用相同的 binding key。
binding key 并不是在所有情况下都生效，它依赖于 Exchange Type，比如 fanout 类型的 Exchange 就会无视 binding key，而是将消息路由到所有绑定到该 Exchange 的 Queue。</p>
<p>###Message(消息)：
生产者传递给消费者的信息，由有效载荷(payload)和标签(label)组成，其中有效载荷即传输的数据</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="消息属性和有效载荷消息主体">消息属性和有效载荷（消息主体）<a href="#消息属性和有效载荷消息主体" class="hash-link" aria-label="Direct link to 消息属性和有效载荷（消息主体）" title="Direct link to 消息属性和有效载荷（消息主体）">​</a></h4>
<p>AMQP 模型中的消息（Message）对象是带有属性（Attributes）的。例如：</p>
<ul>
<li>Content type（内容类型）</li>
<li>Content encoding（内容编码）</li>
<li>Routing key（路由键）</li>
<li>Delivery mode (persistent or not) 投递模式（持久化 或 非持久化）</li>
<li>Message priority（消息优先权）</li>
<li>Message publishing timestamp（消息发布的时间戳）</li>
<li>Expiration period（消息有效期）</li>
<li>Publisher application id（发布应用的 ID）</li>
</ul>
<p>有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。</p>
<p>AMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用&quot;content-type&quot; 和 &quot;content-encoding&quot; 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="producer生产者">Producer(生产者)<a href="#producer生产者" class="hash-link" aria-label="Direct link to Producer(生产者)" title="Direct link to Producer(生产者)">​</a></h3>
<p>创建消息，发布到代理服务器(Message Broker)</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="consumer消费者">Consumer(消费者)<a href="#consumer消费者" class="hash-link" aria-label="Direct link to Consumer(消费者)" title="Direct link to Consumer(消费者)">​</a></h3>
<p>连接代理服务器，并订阅到队列上，代理服务器将发送消息给一个订阅/监听的消费者，消费者只能接收消息的有效载荷(payload)部分。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="prefetch-count">Prefetch count<a href="#prefetch-count" class="hash-link" aria-label="Direct link to Prefetch count" title="Direct link to Prefetch count">​</a></h3>
<p>如果有多个消费者同时订阅同一个 Queue 中的消息，Queue 中的消息会被平摊给多个消费者。如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置 prefetchCount 来限制 Queue 每次发送给每个消费者的消息数，比如我们设置 prefetchCount=1，则 Queue 每次给每个消费者发送一条消息；消费者处理完这条消息后 Queue 会再给该消费者发送一条消息。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="持久化">持久化<a href="#持久化" class="hash-link" aria-label="Direct link to 持久化" title="Direct link to 持久化">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="queue-持久化">Queue 持久化<a href="#queue-持久化" class="hash-link" aria-label="Direct link to Queue 持久化" title="Direct link to Queue 持久化">​</a></h4>
<p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。</p>
<p>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="exchange-持久化">Exchange 持久化<a href="#exchange-持久化" class="hash-link" aria-label="Direct link to Exchange 持久化" title="Direct link to Exchange 持久化">​</a></h4>
<p>Exchange 可以有两个状态：持久（durable）、暂存（transient），持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="message-持久化">Message 持久化<a href="#message-持久化" class="hash-link" aria-label="Direct link to Message 持久化" title="Direct link to Message 持久化">​</a></h4>
<p>Message 能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="消息确认">消息确认<a href="#消息确认" class="hash-link" aria-label="Direct link to 消息确认" title="Direct link to 消息确认">​</a></h3>
<p>消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？有 2 种方式：</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="自动确认模式automatic-acknowledgement-model">自动确认模式（automatic acknowledgement model）<a href="#自动确认模式automatic-acknowledgement-model" class="hash-link" aria-label="Direct link to 自动确认模式（automatic acknowledgement model）" title="Direct link to 自动确认模式（automatic acknowledgement model）">​</a></h5>
<p>当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="显式确认模式explicit-acknowledgement-model">显式确认模式（explicit acknowledgement model）<a href="#显式确认模式explicit-acknowledgement-model" class="hash-link" aria-label="Direct link to 显式确认模式（explicit acknowledgement model）" title="Direct link to 显式确认模式（explicit acknowledgement model）">​</a></h5>
<p>待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）</p>
<p>在实际应用中，可能会发生消费者收到 Queue 中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。为了避免这种情况发生，我们可以要求消费者在消费完消息后发送一个回执给 RabbitMQ，RabbitMQ 收到消息回执（Message acknowledgment）后才将该消息从 Queue 中移除；如果 RabbitMQ 没有收到回执并检测到消费者的 RabbitMQ 连接断开，则 RabbitMQ 会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在 timeout 概念，一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的 RabbitMQ 连接断开。……
这里会产生另外一个问题，如果在处理完业务逻辑后，忘记发送回执给 RabbitMQ，这将会导致严重的 bug——Queue 中堆积的消息会越来越多；消费者重启后会重复消费这些消息并重复执行业务逻辑…</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="拒绝消息">拒绝消息<a href="#拒绝消息" class="hash-link" aria-label="Direct link to 拒绝消息" title="Direct link to 拒绝消息">​</a></h3>
<p>当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="预取消息">预取消息<a href="#预取消息" class="hash-link" aria-label="Direct link to 预取消息" title="Direct link to 预取消息">​</a></h3>
<p>在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/en/docs/tags/amqp">AMQP</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Tools/消息队列/RabbitMQ原理/RabbitMQ原理.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--next" href="/en/docs/Tools/Redis使用"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Redis 使用</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#什么是-amqp" class="table-of-contents__link toc-highlight">什么是 AMQP</a></li><li><a href="#amqp-原理" class="table-of-contents__link toc-highlight">AMQP 原理</a></li><li><a href="#amqp-组件及概念" class="table-of-contents__link toc-highlight">AMQP 组件及概念</a><ul><li><a href="#broker" class="table-of-contents__link toc-highlight">Broker</a></li><li><a href="#virtual-host" class="table-of-contents__link toc-highlight">Virtual host</a></li><li><a href="#connection" class="table-of-contents__link toc-highlight">Connection</a></li><li><a href="#channel" class="table-of-contents__link toc-highlight">Channel</a></li><li><a href="#exchange" class="table-of-contents__link toc-highlight">Exchange</a><ul><li><a href="#routing-key" class="table-of-contents__link toc-highlight">Routing key</a></li><li><a href="#route-type" class="table-of-contents__link toc-highlight">Route Type</a><ul><li><a href="#direct-exchange直连交换机" class="table-of-contents__link toc-highlight">Direct exchange（直连交换机）</a></li><li><a href="#fanout-exchange扇型交换机" class="table-of-contents__link toc-highlight">Fanout exchange（扇型交换机）</a></li><li><a href="#topic-exchange主题交换机" class="table-of-contents__link toc-highlight">Topic exchange（主题交换机）</a></li><li><a href="#headers-exchange头交换机" class="table-of-contents__link toc-highlight">Headers exchange（头交换机）</a></li></ul></li><li><a href="#exchange-其他属性" class="table-of-contents__link toc-highlight">Exchange 其他属性</a></li></ul></li><li><a href="#queue" class="table-of-contents__link toc-highlight">Queue</a><ul><li><a href="#queue-关键属性" class="table-of-contents__link toc-highlight">Queue 关键属性</a></li></ul></li><li><a href="#binding" class="table-of-contents__link toc-highlight">Binding</a><ul><li><a href="#binding-key" class="table-of-contents__link toc-highlight">Binding key</a></li><li><a href="#消息属性和有效载荷消息主体" class="table-of-contents__link toc-highlight">消息属性和有效载荷（消息主体）</a></li></ul></li><li><a href="#producer生产者" class="table-of-contents__link toc-highlight">Producer(生产者)</a></li><li><a href="#consumer消费者" class="table-of-contents__link toc-highlight">Consumer(消费者)</a></li><li><a href="#prefetch-count" class="table-of-contents__link toc-highlight">Prefetch count</a></li><li><a href="#持久化" class="table-of-contents__link toc-highlight">持久化</a><ul><li><a href="#queue-持久化" class="table-of-contents__link toc-highlight">Queue 持久化</a></li><li><a href="#exchange-持久化" class="table-of-contents__link toc-highlight">Exchange 持久化</a></li><li><a href="#message-持久化" class="table-of-contents__link toc-highlight">Message 持久化</a></li></ul></li><li><a href="#消息确认" class="table-of-contents__link toc-highlight">消息确认</a><ul><li><a href="#自动确认模式automatic-acknowledgement-model" class="table-of-contents__link toc-highlight">自动确认模式（automatic acknowledgement model）</a></li><li><a href="#显式确认模式explicit-acknowledgement-model" class="table-of-contents__link toc-highlight">显式确认模式（explicit acknowledgement model）</a></li></ul></li><li><a href="#拒绝消息" class="table-of-contents__link toc-highlight">拒绝消息</a></li><li><a href="#预取消息" class="table-of-contents__link toc-highlight">预取消息</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/en/docs/Tutorial/React Native跨端开发环境的副本/React Native跨端开发环境">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/ilcb" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 DocHub, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>